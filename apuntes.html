<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APUNTES</title>
    <link rel="stylesheet" href="css/estilosApuntes.css">

</head>

<body>
    <h1>Curso Profesional de Git y GitHub</h1>
    <div>
        <h3 class="subtitulos"> Clase 11 - ¿Qué es branch (rama) y cómo funciona un Merge en Git?</h3>
        <p>Una rama o branch es una version del codigo del proyecto sobre el que se esta trabajando estas ramas ayudan a
            mantener el orden en el control de versiones y manipular codigo de forma segura</p>
        <h4>Clases de ramas (branch)</h4>
        <p>
            1.Rama main(Master)<br>
            2.Rama develoment: Cuando decides hacer experimentos esta rama es la que tienes que utilizar<br>
            3.Rama Hotfix: si encuentra algun bug
        </p>
        <h4>¿Como crear una rama?</h4>
        <p>Se crea con git branch, para tener una nueva funcion en la misma rama se crea git branch new_branch.
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 12 - Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h3>
        <p>El comando <u> Git checkout </u> + <u> ID del commit </u> nos permite viajar en el tiempo. Podemos volver a
            cualquier
            version anterior de un archivo especifico o incluso del proyecto entero </p>
        <h4>Como usar Git Reset</h4>
        <p>
            1. git reset --soft [indicador del commit]: elimina los cambios hasta el staging area <br>
            2. git reset --mixed [indicador del commit]: elimina los cambios hasta el working area <br>
            3. git reset --hard [indicador del commit]: regresa hasta el commit del [indicador del commit] <br>
        </p>
        <h4>¿Que se hizo en la clase?</h4>
        <p>Se trabajo en manejar el git reset y git checkout, creamos el archivo el proyecto y lo conectamos con el css
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 13 - Git reset vs Git rm</h3>
        <h4>Git reset</h4>
        <p>El comando git reset es una herramienta poderosa que te permite deshacer o revertir cambios en tu repositorio
            de Git. Lo puedes ejecutar de tres maneras diferentes,
            con las líneas de comando --soft, --mixed y --hard.</p>



        <h4>Git rm</h4>
        <p>Por otro lado, git rm es un comando que nos ayuda a eliminar archivos de Git sin eliminar su historial del
            sistema de versiones. Para recuperar el archivo eliminado, necesitamos retroceder en la historia del
            proyecto,
            recuperar el último commit y obtener la última confirmación antes de la eliminación del archivo.</p>


        <h4>Variaciones de Git rm</h4>
        <p>git rm --cached: Elimina archivos del repositorio local y del área de staging, pero los mantiene en el disco
            duro. Deja de trackear el historial de cambios de estos archivos, por lo que quedan en estado untracked.
            <br>
            git rm --force: Elimina los archivos de Git y del disco duro. Git guarda todo, por lo que podemos recuperar
            archivos eliminados si es necesario (empleando comandos avanzados).
        </p>

        <h4>Resumen</h4>
        <p>
            Para evitar problemas en el trabajo, es valioso entender las implicaciones y riesgos de cada comando y
            elegir el enfoque adecuado según las necesidades y el flujo de trabajo del proyecto. <br>
            <br>
            Con git rm eliminamos un archivo de Git, pero mantenemos su historial de cambios. Si no queremos borrar un
            archivo, sino dejarlo como está y actualizarlo después, no debemos usar este comando en este commit. <br>
            <br>
            Empleando git reset HEAD, movemos los cambios de Staging a Unstaged, pero mantenemos el archivo en el
            repositorio con los últimos cambios en los que hicimos commit. Así, no perdemos nada relevante.
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 14 - Flujo de trabajo basico con un repositorio remoto</h3>
        <p>Cuando empiezas a trabajar en un entorno local, el proyecto vive únicamente en tu computadora. Esto significa
            que no hay forma de que otros miembros del equipo trabajen en él. <br>
            <br>
            Para solucionar esto, utilizamos los servidores remotos: un nuevo estado que deben seguir nuestros archivos
            para conectarse y trabajar con equipos de cualquier parte del mundo.
        </p>
        <h4>Comandos para trabajo remoto co Git</h4>
        <p> - <u>Git clone url_del_servidor_remoto</u> : Nos permite descargar los archivos de la última versión de la
            rama principal y todo el historial de cambios en la carpeta .git. <br>
            - <u>Git push</u>: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios
            al servidor remoto. <br>
            - <u>Git fetch</u>: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro
            repositorio local (en caso de que hayan, por supuesto). <br>
            - <u>Git merge</u>: También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar
            los últimos cambios del servidor remoto y nuestro directorio de trabajo. <br>
            - <u>Git pull</u>: Básicamente, git fetch y git merge al mismo tiempo.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 15 - Introducción a las ramas o branches de Git</h3>
        <p>Las ramas (branches) son la forma de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de la
            rama principal. Esto porque queremos trabajar una parte muy específica de la aplicación o simplemente
            experimentar.</p>
        <h4>Cómo funcionan las ramas en GIT</h4>
        <p>- git branch -nombre de la rama-: Con este comando se genera una nueva rama. <br>

            - git checkout -nombre de la rama-: Con este comando puedes saltar de una rama a otra. <br>

            - git checkout -b rama: Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de
            git branch y git checkout al mismo tiempo. <br>

            - git reset id-commit: Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag.,
            eliminando el historial de los commit posteriores al tag seleccionado. <br>

            - git checkout rama-o-id-commit: Nos lleva a cualquier commit sin borrar los commit posteriores al tag
            seleccionado.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 16 - Fusión de ramas con Git merge</h3>
        <p>La fusión en Git es la forma en que este sistema une un historial bifurcado. El comando git merge permite
            integrar líneas de desarrollo independientes generadas por git branch en una sola rama. Con este comando,
            podemos crear un nuevo commit que combina dos ramas o branches: la rama actual y la rama que se indica
            después del comando. <br>
            <br>
            Estos comandos de fusión del merge afectan solo a la rama actual y no a la rama de destino. Por lo tanto, te
            recomendamos utilizar git checkout para seleccionar la rama actual y git branch -d para eliminar la rama de
            destino obsoleta.
        </p>
        <h4>Funcionamiento de Git merge</h4>
        <p>Git merge fusiona secuencias de confirmaciones en un solo historial, generalmente para combinar dos ramas.
            Busca una confirmación de base común y genera una confirmación de fusión que representa la combinación de
            las dos ramas hasta el resultado final.</p>

        <h4>¿Cómo unir dos ramas en git?</h4>
        <p>Ahora bien, para combinar ramas en tu repositorio local, usa git checkout para cambiar a la rama donde deseas
            fusionar. Por lo general, esta es la rama principal. Luego, emplea git merge y especifica el nombre de la
            otra rama que deseas traer a esta rama. Ten en cuenta que esto es una combinación de avance rápido.</p>

        <h4>¿Cómo realizar un merge en git?</h4>
        <p>git checkout master <br>
            git merge cabecera</p>

        <h4 class="subtitulos">Clase 17 - Resolución de conflictos al hacer un merge</h4>
        <p>Git nunca borra nada, a menos que nosotros se lo indiquemos. Cuando usamos los comandos git merge o git
            checkout estamos cambiando de rama o creando un nuevo commit, no borrando ramas ni commits (recuerda que
            puedes borrar commits con git reset y ramas con git branch -d).</p>
        <h4>Cómo revertir un merge</h4>
        <p>git merge --abort</p>
        <h4>Conflictos en repositorios remotos</h4>
        <p>En el trabajo colaborativo con otros, es esencial utilizar un repositorio remoto. Se puede copiar un
            repositorio remoto al directorio local con "git clone <url>" y enviar cambios con "git push". Para
                actualizar el repositorio local, se usa "git fetch" seguido de "git merge". Para realizar ambas acciones
                en un solo comando, se emplea "git pull". Facilitando la creación de commits, se combina "git add" y
                "git commit -m" con "git commit -am". La creación y cambio entre ramas se logra con "git branch <nombre>
                    " y "git checkout <branch>" respectivamente. Después de realizar cambios en una rama, se fusionan
                        con "git merge", transformando esa rama en la principal. Los merges, que son commits, pueden
                        generar conflictos que requieren solución manual.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 18 - Cómo funcionan las llaves públicas y privadas</h3>
        <p>Las llaves públicas y privadas, conocidas también como cifrado asimétrico de un solo camino, sirven para
            mandar mensajes privados entre varios nodos con la lógica de que firmas tu mensaje con una llave pública
            vinculada con una llave privada que puede leer el mensaje.
            <br><br>
            Las llaves públicas y privadas nos ayudan a cifrar y descifrar nuestros archivos de forma que los podamos
            compartir sin correr el riesgo de que sean interceptados por personas con malas intenciones.

        <h4>Cómo funciona un mensaje cifrado con llaves públicas y privada</h4>
        <p>1.Ambas personas deben crear su llave pública y privada. <br>
            2.Ambas personas pueden compartir su llave pública a las otras partes (recuerda que esta llave es pública,
            no hay problema si la “interceptan”).<br>
            3.La persona que quiere compartir un mensaje puede usar la llave pública de la otra persona para cifrar los
            archivos y asegurarse que solo puedan ser descifrados con la llave privada de la persona con la que queremos
            compartir el mensaje.<br>
            4.El mensaje está cifrado y puede ser enviado a la otra persona sin problemas en caso de que los archivos
            sean interceptados.<br>
            5.La persona a la que enviamos el mensaje cifrado puede emplear su llave privada para descifrar el mensaje y
            ver los archivos.</p>
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 19 - Configura tus llaves SSH en local</h3>
        <h4>Cómo generar tus llaves SSH</h4>
        <h5>1. Generar tus llaves SSH**</h5>
        <p>Recuerda que es muy buena idea proteger tu llave privada con una contraseña.
            <br>
            ssh-keygen -t rsa -b 4096 -C "tu@email.com"
        </p>
        <h5>2. Terminar de configurar nuestro sistema.</h5>
        <p>- Encender el “servidor” de llaves SSH de tu computadora: <br>
            eval $(ssh-agent -s) <br><br>
            - Añadir tu llave SSH a este “servidor”: <br>
            ssh-add ruta-donde-guardaste-tu-llave-privada</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 20 - Uso de GitHub</h3>
        <p>
            GitHub es una plataforma que facilita el almacenamiento de repositorios de Git. Permite operar visualmente,
            evitando la consola de comandos. Después de crear una cuenta, se pueden crear o importar repositorios,
            formar organizaciones, contribuir a proyectos y más. <br>
            <br>
            El README.md es crucial para describir proyectos y sus instrucciones. <br>
            <br>
            Para clonar un repositorio desde GitHub, se copia la URL y se ejecuta "git clone + URL" para descargar la
            versión del proyecto. Esto es útil para quienes desean contribuir.
        </p>
    </div>
    <h4>Cómo conectar un repositorio de GitHub a nuestro documento local</h4>
    <p>
        Si queremos conectar el repositorio de GitHub con nuestro repositorio local, que creamos usando el comando git
        init, debemos ejecutar las siguientes instrucciones: <br>
        <br>
        1.Guardar la URL del repositorio de GitHub con el nombre de origin <br>
        <u>git remote add origin URL</u> <br>
        <br>

        2.Verificar que la URL se haya guardado correctamente: <br>
        <u>git remote</u><br>
        <u>git remote -v</u> <br>
        <br>

        3.Traer la versión del repositorio remoto y hacer merge para crear un commit con los archivos de ambas partes.
        Podemos usar git fetch y git merge o solo git pull con el flag --allow-unrelated-histories: <br>
        <u>git pull origin master --allow-unrelated-histories</u> <br>
        <br>

        4.Por último, ahora sí podemos hacer git push para guardar los cambios de nuestro repositorio local en GitHub:
        git push origin master <br>
    </p>
    <h4>Cómo autenticarte en GitHub 2022</h4>
    <p>Para autenticarte en GitHub en 2022 y cambiar a la nueva convención 'main' en lugar de 'master':
        <br> <br>
        1. Renombra la rama 'máster' a 'main': `git branch -M main`
        <br> <br>
        2. Crea un token de acceso personal: <br>
        - Ingresa a tu cuenta de GitHub. <br>
        - Ve a Settings -> Developer settings -> Personal access tokens. <br>
        - Genera un nuevo token con permisos 'repo'. <br>
        <br>
        Utiliza este token en lugar de tu contraseña para operaciones como push.
    </p>

    <h3 class="subtitulos">Clase 21 - Cambios en GitHub: de master a main</h3>
    <p>El escritor argentino Julio Cortázar sostiene que las palabras tienen color y peso, y aunque los sinónimos
        existen, no expresan lo mismo. Feo no es igual a desagradable, al igual que aromático no es lo mismo que
        oloroso.
        <br><br>
        En el contexto del curso profesional de Git & GitHub, desde el 1 de octubre de 2020, GitHub cambió el nombre de
        la rama principal de "master" a "main". Este cambio surgió tras una reflexión profunda impulsada por el
        movimiento #BlackLivesMatter. La tecnología ha empleado términos como master, slave, blacklist o whitelist, y se
        espera que evolucionen.
        <br><br>
        Las palabras importan, y a partir de ahora, cuando escuches a Freddy mencionar "master", se refiere a "main".
    </p>
    <div>
        <h3 class="subtitulos">Clase 22 - Tu primer push</h3>
        <p>La creación de claves SSH es un paso único por cada computadora para conectar a GitHub de manera segura.
            Después de generar las llaves, proporcionamos la llave pública a GitHub para autenticación sin ingresar
            usuario y contraseña constantemente. Accede a la Configuración de Llaves SSH en GitHub, crea una nueva llave
            con nombre y contenido de la llave pública. Actualiza la URL del repositorio remoto para usar SSH en lugar
            de HTTPS. <br><br>
            <u>git remote set-url origin url-ssh-del-repositorio-en-github</u>
        </p>
        <h4>Comandos para copiar la llave SSH:</h4>
        <p><u>clip < ~/.ssh/id_rsa.pub</u>
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 23 - Git tag y versiones en Github </h3>
        <p>En Git, las etiquetas o Git tags tienen un papel importante al asignar versiones a los commits más
            significativos de un proyecto. Aprender a utilizar el comando git tag, entender los diferentes tipos de
            etiquetas, cómo crearlas, eliminarlas y compartirlas, es esencial para un flujo de trabajo eficiente.</p>

        <h4>Creación de etiquetas en Git</h4>
        <p>Para crear una etiqueta, ejecuta el siguiente comando: <br>
            <br>
            git tag tagname <br>
            Sustituye tagname con un identificador semántico que refleje el estado del repositorio en el momento
            de la creación. Git admite etiquetas anotadas y ligeras. <br>
            <br>
            Las etiquetas anotadas almacenan información adicional como la fecha, etiquetador y correo
            electrónico, y son ideales para publicaciones públicas. Las etiquetas ligeras son más simples y se
            emplean como “marcadores” de una confirmación específica.
        </p>
        <h4>Listado de etiquetas</h4>
        <p>Para obtener una lista de etiquetas en el repositorio, ejecuta el siguiente comando: <br>
            <br>
            git tag <br>
            Esto mostrará una lista de las etiquetas existentes, como: <br>
            <br>
            v1.0 <br>
            v1.1 <br>
            v1.2 <br>
            Para perfeccionar la lista, puedes utilizar opciones adicionales, como -l con una expresión comodín.
        </p>

        <h4>Uso compartido de etiquetas</h4>
        <p>Compartir etiquetas requiere un enfoque explícito al usar el comando git push. Por defecto, las etiquetas no
            se envían automáticamente. Para enviar etiquetas específicas, utiliza: <br>
            <br>
            git push origin tagname <br>
            Para enviar varias etiquetas a la vez, usa: <br>

            git push origin --tags
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 24 - Manejo de ramas en GitHub</h3>
        <p>Este fragmento destaca la función de las ramas en Git, un sistema de control de versiones. Las ramas permiten
            realizar cambios en archivos sin afectar la versión principal (master). Se puede trabajar con ramas
            localmente sin necesidad de enviarlas a GitHub, y también puede haber ramas en GitHub que no se utilicen
            localmente. Es esencial aprender a manejar las ramas para trabajar de manera profesional. <br> <br>

            Cuando se realiza un commit en una rama diferente a la principal, tanto el historial (git log) como los
            archivos se ven afectados. Sin embargo, la ventaja principal de utilizar ramas es que estas modificaciones
            solo afectan a la rama específica en la que se realizaron. Al cambiar a otra rama, las modificaciones de la
            rama anterior no aparecen en la nueva rama, lo que facilita la gestión y organización de los cambios en un
            proyecto.</p>
        <h4>Comandos para manejo de ramas en GitHub</h4>
        <p>Crear una rama:
            <u>git branch branchName</u> <br> <br>
            Movernos a otra rama:
            <u>git checkout branchName </u><br> <br>
            Crear una rama en el repositorio local:
            <u>git branch nombre-de-la-rama o git checkout -b nombre-de-la-rama.</u> <br> <br>
            Publicar una rama local al repositorio remoto:
            <u>git push origin nombre-de-la-rama.</u> <br> <br>
            Recuerda que podemos ver gráficamente nuestro entorno y flujo de trabajo local con Git utilizando el comando
            gitk. Gitk fue el primer visor gráfico que se desarrolló para ver de manera gráfica el historial de un
            repositorio de Git.
        </p>
        <div>
            <h3 class="subtitulos">Clase 25 - Configurar múltiples colaboradores en un repositorio de GitHub</h3>
            <p>Por defecto, cualquier persona puede clonar o descargar tu proyecto desde GitHub, pero no pueden crear
                commits, ni ramas. Esto quiere decir que pueden copiar tu proyecto pero no colaborar con él. Existen
                varias formas de solucionar esto para poder aceptar contribuciones. Una de ellas es añadir a cada
                persona de nuestro equipo como colaborador de nuestro repositorio.</p>
            <h4>Cómo agregar colaboradores en Github</h4>
            <p>Solo debemos entrar a la configuración de colaboradores de nuestro proyecto. Se encuentra en: <br>
                Repositorio > Settings > Collaborators</p>
            <img src="https://static.platzi.com/media/user_upload/collaborator-ccc98946-723f-4866-bd45-babd1163d987.jpg"
                alt="imagen" id="imagen">
            <p>Si, como colaborador, agregaste erróneamente el mensaje del commit, lo puedes cambiar de la siguiente
                manera: <br><br>

                - Hacer un commit con el nuevo mensaje que queremos, esto nos abre el editor de texto de la terminal:
                <br>
                git commit —amend <br>
                - Corregimos el mensaje <br>
                - Traer el repositorio remoto <br>
                git pull origin master <br>
                - Ejecutar el cambio <br>
                git push --set-upstream origin master
            </p>
        </div>
    </div>
    <div>
        <h3 class="subtitulos">Clase 26 - Flujo de trabajo profesional: Haciendo merge de ramas de desarrollo a master
        </h3>
        <p>Para poder desarrollar software de manera óptima y ordenada, necesitamos tener un flujo
            de trabajo profesional, que nos permita trabajar en conjunto sin interrumpir el trabajo de otros
            desarrolladores. Una buena práctica de flujo de trabajo sería la siguiente: <br> <br>

            1.Crear ramas<br>
            2. Asignar una rama a cada programador<br>
            3. El programador baja el repositorio con git pull origin master<br>
            4. El programador cambia de rama<br>
            5. El programador trabaja en esa rama y hace commits<br>
            6. El programador sube su trabajo con git push origin #nombre_rama<br>
            7. El encargado de organizar el proyecto baja, revisa y unifica todos los cambios</p>

    </div>
    <div>
        <h3 class="subtitulos">Clase 27 - Flujo de trabajo profesional con Pull requests</h3>
        <p>En entornos profesionales, la rama master suele bloquearse, y para incorporar código, se sigue un proceso que
            incluye code review y merge request después de la aprobación. Las pruebas se realizan en servidores de
            staging develop antes de pasar al servidor de producción con el merge request.

            En proyectos de código abierto, la colaboración se basa en pull requests (PR). Colaborar implica forkear el
            proyecto, implementar cambios en una nueva rama, hacer un PR y esperar la aprobación o sugerencias de los
            administradores, llamados DevOps, antes del merge en la rama principal.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 28 - Utilizando Pull Requests en GitHub</h3>
        <p>En resumen, un Pull Request (PR) en GitHub es una herramienta que facilita a un equipo solicitar la revisión
            y aprobación de los cambios realizados en el código antes de fusionarlos en la rama principal del
            desarrollo, llamada "master" o "main". Al crear un PR, se inicia una conversación donde los miembros del
            equipo pueden revisar, seguir y comentar sobre los cambios propuestos, lo que permite identificar posibles
            errores o problemas antes de integrarlos en la rama principal. Esta práctica contribuye a mantener el
            proyecto más limpio y estable.</p>
        <h4>Estructura de la incorporación de cambios</h4>
        <img src="https://static.platzi.com/media/user_upload/imagen-articlases-optimizada%20%281%29-395f58fb-b44b-4729-be7d-38549ea2a157.jpg"
            alt="imagen Clase 28" id="imagen">
        Resumen:

        <h4>Solicitando un Pull Request:</h4>
        <p> 1. Crea una rama paralela con `git checkout -b <rama>` antes de hacer cambios en el código para evitar
                afectar
                la rama principal. <br> <br>
                2. Realiza commits con `git commit -am '<Comentario>'` después de realizar modificaciones en los
                    archivos. <br><br>
                    3. Sube los cambios con `git push origin <rama>` desde la rama local al repositorio remoto. <br>
                        <br>
                        4. Crea un Pull Request en el repositorio remoto (por ejemplo, en GitHub), seleccionando la rama
                        principal como destino y tu rama con cambios como comparación. <br><br>
                        5. Los revisores proporcionan feedback en la sección de comentarios del Pull Request.</p>

        <h4>Aceptando un Pull Request:</h4>
        <p>1. Si estás satisfecho con los cambios propuestos, acepta el Pull Request en GitHub. <br> <br>
            2. Realiza el merge en la rama principal seleccionando la opción correspondiente en GitHub.</p>

        <h4>Corrección de un Pull Request:</h4>
        <p>1. Lee cuidadosamente los comentarios y feedback de los revisores. <br> <br>
            2. Regresa a tu rama local con `git checkout rama`.<br><br>
            3. Realiza las correcciones necesarias en los archivos basándote en los comentarios y feedback.<br><br>
            4. Crea un nuevo commit con `git commit -am 'Comentario'`.<br><br>
            5. Sube los cambios corregidos al repositorio remoto con `git push origin rama.<br><br>
            6. El Pull Request se actualiza automáticamente con los cambios realizados.<br><br>
            7. Comunica a los revisores que has realizado las correcciones y que el Pull Request
            está listo para ser revisado nuevamente.<br><br>

            <b>Recuerda que la comunicación abierta y clara con los revisores es esencial para una
                colaboración exitosa en el proceso de revisar y aceptar Pull Requests.</b>
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 29 - Creando un Fork, contribuyendo a un repositorio</h3>
        <h4>Forks en GitHub:</h4>
        <p>- Los forks son una característica única de GitHub que permite crear una copia exacta de un repositorio en
            GitHub. <br> <br>
            - Un fork actúa como un nuevo repositorio git independiente, aunque comparte una historia común con el
            original. <br> <br>
            - Al realizar un fork, te conviertes en el dueño del repositorio fork, con todos los permisos para trabajar
            en él. <br> <br>
            - Los forks son esenciales para el modelo de desarrollo open source, permitiendo a personas contribuir a
            proyectos sin ser colaboradores directos.</p>

        <h4>Haciendo un Fork Remoto desde Consola:</h4>
        <p>1. Al realizar un fork en GitHub, se puede hacer pull request desde el repositorio fork propio. <br><br>
            2. Para trabajar con múltiples repositorios remotos, se puede agregar un remoto adicional desde la consola
            con git remote add [nombre_del_remoto] [url_del_remoto]`. <br><br>
            3. Ejemplo: `git remote add upstream https://github.com/freddier/hyperblog`. <br><br>
            4. Se pueden realizar operaciones como pull, fetch y push con el nuevo remoto, por ejemplo: `git pull
            [remoto] [rama] o git pull upstream master.<br><br>
            5. Este nuevo flujo de trabajo implica hacer pull desde el remoto original (upstream) y push al
            repositorio fork propio (origin) para enviar pull requests.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 30 - Haciendo deployment a un servidor</h3>

        <h4>Deploy:</h4>
        <p>- El deploy es el proceso de enviar uno o varios archivos a un servidor, que puede ser de prueba, desarrollo
            o producción.</p>

        <h4>Pasos para Deployment en un Servidor Web:</h4>
        <p>1. Acceder a la carpeta de archivos del servidor.<br><br>
            2. Copiar el enlace de clonación (HTTPS o SSH) del repositorio en GitHub.<br><br>
            3. Clonar el repositorio en la carpeta deseada con el comando git clone [url].<br><br>
            4. Realizar cambios y commits en GitHub.<br><br>
            5. Traer las actualizaciones al repositorio local en la carpeta del servidor con `git pull [ramaRemota]
            main.<br><br>
            6. Proteger el archivo `.git` para garantizar la seguridad.<br><br>
            7. La conexión entre GitHub y el servidor puede realizarse mediante herramientas como Travis (pago) o
            Jenkins (Open source).</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 31 - Hazme un pull request</h3>
        <p>Esta clase fue un reto que nos propuso Fredy Vegga de hacer un pull request a su repositorio</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 32 - Ignorar archivos en el repositorio con .gitignore</h3>
        <p>No todos los archivos deben ser incluidos en un repositorio debido a razones de seguridad y eficiencia en el
            desarrollo. Archivos como contraseñas (.env), blobs grandes y archivos generados por comandos (por ejemplo,
            node_modules) no deben ser compartidos públicamente ni ralentizar el proceso de desarrollo. Para evitar la
            inclusión de estos archivos no deseados, se utiliza un archivo llamado .gitignore en la raíz del
            repositorio, que contiene reglas para especificar qué archivos deben ser ignorados al realizar commits. Esto
            asegura que ciertos archivos sensibles o innecesarios no se suban al repositorio.
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 33 - Readme.md es una excelente práctica</h3>
        <p>El archivo README.md es un componente esencial en un proyecto, destinado a explicar su propósito, cómo
            utilizarlo y cualquier otra información relevante. Escrito en Markdown, un estándar de formato de texto, los
            README.md son comúnmente utilizados en plataformas como GitHub, Platzi y Wikipedia. Aunque estos archivos
            pueden ubicarse en diversas carpetas, el más crucial se encuentra en la raíz del proyecto, proporcionando
            información clave para los colaboradores. Es importante destacar que solo los archivos README.md se
            mostrarán automáticamente en GitHub.</p>
    </div>
</body>