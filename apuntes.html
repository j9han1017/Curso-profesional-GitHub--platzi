<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APUNTES</title>
    <link rel="stylesheet" href="css/estilosApuntes.css">

</head>

<body>
    <h1>Curso Profesional de Git y GitHub</h1>
    <div>
        <h3 class="subtitulos"> Clase 11 - ¿Qué es branch (rama) y cómo funciona un Merge en Git?</h3>
        <p>Una rama o branch es una version del codigo del proyecto sobre el que se esta trabajando estas ramas ayudan a
            mantener el orden en el control de versiones y manipular codigo de forma segura</p>
        <h4>Clases de ramas (branch)</h4>
        <p>
            1.Rama main(Master)<br>
            2.Rama develoment: Cuando decides hacer experimentos esta rama es la que tienes que utilizar<br>
            3.Rama Hotfix: si encuentra algun bug
        </p>
        <h4>¿Como crear una rama?</h4>
        <p>Se crea con git branch, para tener una nueva funcion en la misma rama se crea git branch new_branch.
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 12 - Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h3>
        <p>El comando <u> Git checkout </u> + <u> ID del commit </u> nos permite viajar en el tiempo. Podemos volver a
            cualquier
            version anterior de un archivo especifico o incluso del proyecto entero </p>
        <h4>Como usar Git Reset</h4>
        <p>
            1. git reset --soft [indicador del commit]: elimina los cambios hasta el staging area <br>
            2. git reset --mixed [indicador del commit]: elimina los cambios hasta el working area <br>
            3. git reset --hard [indicador del commit]: regresa hasta el commit del [indicador del commit] <br>
        </p>
        <h4>¿Que se hizo en la clase?</h4>
        <p>Se trabajo en manejar el git reset y git checkout, creamos el archivo el proyecto y lo conectamos con el css
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 13 - Git reset vs Git rm</h3>
        <h4>Git reset</h4>
        <p>El comando git reset es una herramienta poderosa que te permite deshacer o revertir cambios en tu repositorio
            de Git. Lo puedes ejecutar de tres maneras diferentes,
            con las líneas de comando --soft, --mixed y --hard.</p>



        <h4>Git rm</h4>
        <p>Por otro lado, git rm es un comando que nos ayuda a eliminar archivos de Git sin eliminar su historial del
            sistema de versiones. Para recuperar el archivo eliminado, necesitamos retroceder en la historia del
            proyecto,
            recuperar el último commit y obtener la última confirmación antes de la eliminación del archivo.</p>


        <h4>Variaciones de Git rm</h4>
        <p>git rm --cached: Elimina archivos del repositorio local y del área de staging, pero los mantiene en el disco
            duro. Deja de trackear el historial de cambios de estos archivos, por lo que quedan en estado untracked.
            <br>
            git rm --force: Elimina los archivos de Git y del disco duro. Git guarda todo, por lo que podemos recuperar
            archivos eliminados si es necesario (empleando comandos avanzados).
        </p>

        <h4>Resumen</h4>
        <p>
            Para evitar problemas en el trabajo, es valioso entender las implicaciones y riesgos de cada comando y
            elegir el enfoque adecuado según las necesidades y el flujo de trabajo del proyecto. <br>
            <br>
            Con git rm eliminamos un archivo de Git, pero mantenemos su historial de cambios. Si no queremos borrar un
            archivo, sino dejarlo como está y actualizarlo después, no debemos usar este comando en este commit. <br>
            <br>
            Empleando git reset HEAD, movemos los cambios de Staging a Unstaged, pero mantenemos el archivo en el
            repositorio con los últimos cambios en los que hicimos commit. Así, no perdemos nada relevante.
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 14 - Flujo de trabajo basico con un repositorio remoto</h3>
        <p>Cuando empiezas a trabajar en un entorno local, el proyecto vive únicamente en tu computadora. Esto significa
            que no hay forma de que otros miembros del equipo trabajen en él. <br>
            <br>
            Para solucionar esto, utilizamos los servidores remotos: un nuevo estado que deben seguir nuestros archivos
            para conectarse y trabajar con equipos de cualquier parte del mundo.
        </p>
        <h4>Comandos para trabajo remoto co Git</h4>
        <p> - <u>Git clone url_del_servidor_remoto</u> : Nos permite descargar los archivos de la última versión de la
            rama principal y todo el historial de cambios en la carpeta .git. <br>
            - <u>Git push</u>: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios
            al servidor remoto. <br>
            - <u>Git fetch</u>: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro
            repositorio local (en caso de que hayan, por supuesto). <br>
            - <u>Git merge</u>: También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar
            los últimos cambios del servidor remoto y nuestro directorio de trabajo. <br>
            - <u>Git pull</u>: Básicamente, git fetch y git merge al mismo tiempo.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 15 - Introducción a las ramas o branches de Git</h3>
        <p>Las ramas (branches) son la forma de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de la
            rama principal. Esto porque queremos trabajar una parte muy específica de la aplicación o simplemente
            experimentar.</p>
        <h4>Cómo funcionan las ramas en GIT</h4>
        <p>- git branch -nombre de la rama-: Con este comando se genera una nueva rama. <br>

            - git checkout -nombre de la rama-: Con este comando puedes saltar de una rama a otra. <br>

            - git checkout -b rama: Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de
            git branch y git checkout al mismo tiempo. <br>

            - git reset id-commit: Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag.,
            eliminando el historial de los commit posteriores al tag seleccionado. <br>

            - git checkout rama-o-id-commit: Nos lleva a cualquier commit sin borrar los commit posteriores al tag
            seleccionado.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 16 - Fusión de ramas con Git merge</h3>
        <p>La fusión en Git es la forma en que este sistema une un historial bifurcado. El comando git merge permite
            integrar líneas de desarrollo independientes generadas por git branch en una sola rama. Con este comando,
            podemos crear un nuevo commit que combina dos ramas o branches: la rama actual y la rama que se indica
            después del comando. <br>
            <br>
            Estos comandos de fusión del merge afectan solo a la rama actual y no a la rama de destino. Por lo tanto, te
            recomendamos utilizar git checkout para seleccionar la rama actual y git branch -d para eliminar la rama de
            destino obsoleta.
        </p>
        <h4>Funcionamiento de Git merge</h4>
        <p>Git merge fusiona secuencias de confirmaciones en un solo historial, generalmente para combinar dos ramas.
            Busca una confirmación de base común y genera una confirmación de fusión que representa la combinación de
            las dos ramas hasta el resultado final.</p>

        <h4>¿Cómo unir dos ramas en git?</h4>
        <p>Ahora bien, para combinar ramas en tu repositorio local, usa git checkout para cambiar a la rama donde deseas
            fusionar. Por lo general, esta es la rama principal. Luego, emplea git merge y especifica el nombre de la
            otra rama que deseas traer a esta rama. Ten en cuenta que esto es una combinación de avance rápido.</p>

        <h4>¿Cómo realizar un merge en git?</h4>
        <p>git checkout master <br>
            git merge cabecera</p>

        <h4 class="subtitulos">Clase 17 - Resolución de conflictos al hacer un merge</h4>
        <p>Git nunca borra nada, a menos que nosotros se lo indiquemos. Cuando usamos los comandos git merge o git
            checkout estamos cambiando de rama o creando un nuevo commit, no borrando ramas ni commits (recuerda que
            puedes borrar commits con git reset y ramas con git branch -d).</p>
        <h4>Cómo revertir un merge</h4>
        <p>git merge --abort</p>
        <h4>Conflictos en repositorios remotos</h4>
        <p>En el trabajo colaborativo con otros, es esencial utilizar un repositorio remoto. Se puede copiar un
            repositorio remoto al directorio local con "git clone <url>" y enviar cambios con "git push". Para
                actualizar el repositorio local, se usa "git fetch" seguido de "git merge". Para realizar ambas acciones
                en un solo comando, se emplea "git pull". Facilitando la creación de commits, se combina "git add" y
                "git commit -m" con "git commit -am". La creación y cambio entre ramas se logra con "git branch <nombre>
                    " y "git checkout <branch>" respectivamente. Después de realizar cambios en una rama, se fusionan
                        con "git merge", transformando esa rama en la principal. Los merges, que son commits, pueden
                        generar conflictos que requieren solución manual.</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 18 - Cómo funcionan las llaves públicas y privadas</h3>
        <p>Las llaves públicas y privadas, conocidas también como cifrado asimétrico de un solo camino, sirven para
            mandar mensajes privados entre varios nodos con la lógica de que firmas tu mensaje con una llave pública
            vinculada con una llave privada que puede leer el mensaje.
            <br><br>
            Las llaves públicas y privadas nos ayudan a cifrar y descifrar nuestros archivos de forma que los podamos
            compartir sin correr el riesgo de que sean interceptados por personas con malas intenciones.

        <h4>Cómo funciona un mensaje cifrado con llaves públicas y privada</h4>
        <p>1.Ambas personas deben crear su llave pública y privada. <br>
            2.Ambas personas pueden compartir su llave pública a las otras partes (recuerda que esta llave es pública,
            no hay problema si la “interceptan”).<br>
            3.La persona que quiere compartir un mensaje puede usar la llave pública de la otra persona para cifrar los
            archivos y asegurarse que solo puedan ser descifrados con la llave privada de la persona con la que queremos
            compartir el mensaje.<br>
            4.El mensaje está cifrado y puede ser enviado a la otra persona sin problemas en caso de que los archivos
            sean interceptados.<br>
            5.La persona a la que enviamos el mensaje cifrado puede emplear su llave privada para descifrar el mensaje y
            ver los archivos.</p>
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 19 - Configura tus llaves SSH en local</h3>
        <h4>Cómo generar tus llaves SSH</h4>
        <h5>1. Generar tus llaves SSH**</h5>
        <p>Recuerda que es muy buena idea proteger tu llave privada con una contraseña.
            <br>
            ssh-keygen -t rsa -b 4096 -C "tu@email.com"
        </p>
        <h5>2. Terminar de configurar nuestro sistema.</h5>
        <p>- Encender el “servidor” de llaves SSH de tu computadora: <br>
            eval $(ssh-agent -s) <br><br>
            - Añadir tu llave SSH a este “servidor”: <br>
            ssh-add ruta-donde-guardaste-tu-llave-privada</p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 20 - Uso de GitHub</h3>
        <p>
            GitHub es una plataforma que facilita el almacenamiento de repositorios de Git. Permite operar visualmente,
            evitando la consola de comandos. Después de crear una cuenta, se pueden crear o importar repositorios,
            formar organizaciones, contribuir a proyectos y más. <br>
            <br>
            El README.md es crucial para describir proyectos y sus instrucciones. <br>
            <br>
            Para clonar un repositorio desde GitHub, se copia la URL y se ejecuta "git clone + URL" para descargar la
            versión del proyecto. Esto es útil para quienes desean contribuir.
        </p>
    </div>
    <h4>Cómo conectar un repositorio de GitHub a nuestro documento local</h4>
    <p>
        Si queremos conectar el repositorio de GitHub con nuestro repositorio local, que creamos usando el comando git
        init, debemos ejecutar las siguientes instrucciones: <br>
        <br>
        1.Guardar la URL del repositorio de GitHub con el nombre de origin <br>
        <u>git remote add origin URL</u> <br>
        <br>

        2.Verificar que la URL se haya guardado correctamente: <br>
        <u>git remote</u><br>
        <u>git remote -v</u> <br>
        <br>

        3.Traer la versión del repositorio remoto y hacer merge para crear un commit con los archivos de ambas partes.
        Podemos usar git fetch y git merge o solo git pull con el flag --allow-unrelated-histories: <br>
        <u>git pull origin master --allow-unrelated-histories</u> <br>
        <br>

        4.Por último, ahora sí podemos hacer git push para guardar los cambios de nuestro repositorio local en GitHub:
        git push origin master <br>
    </p>
    <h4>Cómo autenticarte en GitHub 2022</h4>
    <p>Para autenticarte en GitHub en 2022 y cambiar a la nueva convención 'main' en lugar de 'master':
        <br> <br>
        1. Renombra la rama 'máster' a 'main': `git branch -M main`
        <br> <br>
        2. Crea un token de acceso personal: <br>
        - Ingresa a tu cuenta de GitHub. <br>
        - Ve a Settings -> Developer settings -> Personal access tokens. <br>
        - Genera un nuevo token con permisos 'repo'. <br>
        <br>
        Utiliza este token en lugar de tu contraseña para operaciones como push.
    </p>

    <h3 class="subtitulos">Clase 21 - Cambios en GitHub: de master a main</h3>
    <p>El escritor argentino Julio Cortázar sostiene que las palabras tienen color y peso, y aunque los sinónimos
        existen, no expresan lo mismo. Feo no es igual a desagradable, al igual que aromático no es lo mismo que
        oloroso.
        <br><br>
        En el contexto del curso profesional de Git & GitHub, desde el 1 de octubre de 2020, GitHub cambió el nombre de
        la rama principal de "master" a "main". Este cambio surgió tras una reflexión profunda impulsada por el
        movimiento #BlackLivesMatter. La tecnología ha empleado términos como master, slave, blacklist o whitelist, y se
        espera que evolucionen.
        <br><br>
        Las palabras importan, y a partir de ahora, cuando escuches a Freddy mencionar "master", se refiere a "main".
    </p>
    <div>
        <h3 class="subtitulos">Clase 22 - Tu primer push</h3>
        <p>La creación de claves SSH es un paso único por cada computadora para conectar a GitHub de manera segura.
            Después de generar las llaves, proporcionamos la llave pública a GitHub para autenticación sin ingresar
            usuario y contraseña constantemente. Accede a la Configuración de Llaves SSH en GitHub, crea una nueva llave
            con nombre y contenido de la llave pública. Actualiza la URL del repositorio remoto para usar SSH en lugar
            de HTTPS. <br><br>
            <u>git remote set-url origin url-ssh-del-repositorio-en-github</u>
        </p>
        <h4>Comandos para copiar la llave SSH:</h4>
        <p><u>clip < ~/.ssh/id_rsa.pub</u>
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 23 - Git tag y versiones en Github </h3>
        <p>En Git, las etiquetas o Git tags tienen un papel importante al asignar versiones a los commits más
            significativos de un proyecto. Aprender a utilizar el comando git tag, entender los diferentes tipos de
            etiquetas, cómo crearlas, eliminarlas y compartirlas, es esencial para un flujo de trabajo eficiente.</p>

        <h4>Creación de etiquetas en Git</h4>
        <p>Para crear una etiqueta, ejecuta el siguiente comando: <br>
            <br>
            git tag tagname <br>
            Sustituye tagname con un identificador semántico que refleje el estado del repositorio en el momento
            de la creación. Git admite etiquetas anotadas y ligeras. <br>
            <br>
            Las etiquetas anotadas almacenan información adicional como la fecha, etiquetador y correo
            electrónico, y son ideales para publicaciones públicas. Las etiquetas ligeras son más simples y se
            emplean como “marcadores” de una confirmación específica.
        </p>
        <h4>Listado de etiquetas</h4>
        <p>Para obtener una lista de etiquetas en el repositorio, ejecuta el siguiente comando: <br>
            <br>
            git tag <br>
            Esto mostrará una lista de las etiquetas existentes, como: <br>
            <br>
            v1.0 <br>
            v1.1 <br>
            v1.2 <br>
            Para perfeccionar la lista, puedes utilizar opciones adicionales, como -l con una expresión comodín.
        </p>

        <h4>Uso compartido de etiquetas</h4>
        <p>Compartir etiquetas requiere un enfoque explícito al usar el comando git push. Por defecto, las etiquetas no
            se envían automáticamente. Para enviar etiquetas específicas, utiliza: <br>
            <br>
            git push origin tagname <br>
            Para enviar varias etiquetas a la vez, usa: <br>

            git push origin --tags
        </p>
    </div>
    <div>
        <h3 class="subtitulos">Clase 24 - Manejo de ramas en GitHub</h3>
        <p>Este fragmento destaca la función de las ramas en Git, un sistema de control de versiones. Las ramas permiten
            realizar cambios en archivos sin afectar la versión principal (master). Se puede trabajar con ramas
            localmente sin necesidad de enviarlas a GitHub, y también puede haber ramas en GitHub que no se utilicen
            localmente. Es esencial aprender a manejar las ramas para trabajar de manera profesional. <br> <br>

            Cuando se realiza un commit en una rama diferente a la principal, tanto el historial (git log) como los
            archivos se ven afectados. Sin embargo, la ventaja principal de utilizar ramas es que estas modificaciones
            solo afectan a la rama específica en la que se realizaron. Al cambiar a otra rama, las modificaciones de la
            rama anterior no aparecen en la nueva rama, lo que facilita la gestión y organización de los cambios en un
            proyecto.</p>
        <h4>Comandos para manejo de ramas en GitHub</h4>
        <p>Crear una rama:
           <u>git branch branchName</u>  <br> <br>
            Movernos a otra rama:
            <u>git checkout branchName </u><br> <br>
            Crear una rama en el repositorio local:
           <u>git branch nombre-de-la-rama o git checkout -b nombre-de-la-rama.</u>  <br> <br>
            Publicar una rama local al repositorio remoto:
           <u>git push origin nombre-de-la-rama.</u> <br> <br>
            Recuerda que podemos ver gráficamente nuestro entorno y flujo de trabajo local con Git utilizando el comando
            gitk. Gitk fue el primer visor gráfico que se desarrolló para ver de manera gráfica el historial de un
            repositorio de Git.</p>
    </div>


</body>

</html>